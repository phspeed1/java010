
# 재귀 (Recursive)
재귀함수는 콜스택에 쌓인다. 재귀함수 앞부분은 순방향, 뒷부분은 역방향으로 실행된다.
선언적 프로그램, 종료조건 필수.

# 정렬 (Sort)
* Selection Sort : 배열에서 가장 작은수를 찾아서 제일 앞부분으로 swap
* Bubble Sort : n 과 n+1 인덱스의 수를 비교해서 swap 제일 큰수를 제일 끝으로 밀어낸다.
* Merge Sort 
 . 각각 정렬된 두개의 배열을 merge 하면서 정렬
 . 시작인덱스, 마지막인덱스를 받아서 배열을 반으로 나눠서 2번 mergeSort() 재귀 호출
 . 재귀함수가 돌아왔을 때는 가운데를 기준으로 왼쪽, 오른쪽이 정렬되어있는 상태이므로  merge() 호출해서 두개의 배열을 병합
 . 병합할 때는 원본을 임시배열에 복사한 후 각각 idx 를 가지고 작은것부터 채워주되, 만약 start 쪽 배열이 다 차지 않았으면 채워준다.
* Quick Sort
 . pivot 값을 기준으로 작은파티션 큰파티션으로 나누는 것을 반복
 . swap 이용

# 탐색(DFS, BFS)
DFS 는 Stack 또는 콜스텍 이용
BFS 는 Queue 또는 루프문 이용
노드 길이 만큼 visited 배열이나 hash 만들어서 이미 이동한곳은 가지 않도록 하면서 재귀 호출
만약 노드별 연결노드 목록이 아닌  엣지 리스트가 온다면 List<Integer>[] adjacencyList = new ArrayList[NodeCnt]; 배열을 만들어 사용
List<List<Integer>> retrivedResult = new ArrayList<>(); 로 탐색 덩어리별로 담을 수 있음


# 순열(permutation)
만들어내야하는조합 즉 arr.length 만큼 왔으면 재귀호출 종료하고, 결과 목록에 만든 조합을 add
후보 즉 arr 에서 하나씩 꺼내서 이미 조합된배열에 있지 않으면 조합에 꺼낸것을 넣고, 재귀호출해서 다음 레벨로 이동
재귀호출이 끝나서 콜스텍에서 꺼내질 때는 마지막에 넣은 것을 빼주어야 한다.

# 조합(Combination)
순열은 {A, B} 와 {B, A} 가 다른 것이지만, 조합은 {A, B} 와 {B, A} 가 같다. 즉 순서 무시

# DP (Dynamic Programming)
피보나치수열을 배열을 이용한 DP 를 이용하면 콜스택도 덜 사용하고 속도도 좋음.

# util
System.out.println("배열출력 : "+Arrays.toString(array));
Arrys.copyof() 로 배열 copy


Arrays.sort(charArray); // char[] 정렬
Arrays.sort(CharacterArray, Collections.reverseOrder()); // Character[] 내림정렬
hashMap.getOrDefault(key, defaultValue);

List<List<Integer>> result = new ArrayList<>();
List<Integer>[] nodeList = new ArrayList[n];

Stack : push(), pop()
Queue : new LinkedList(), offer(), pull()

##############
# Gejava
##############
# 피보나치 수열
n = n-1 + n-2 

# 하노이의 탑
세개의 기둥이 있다. 하기둥에 밑에서부터 위로 큰원판에서 작은원판이 순서대로 쌓여있다.
한번에 하나의 원판만 옮길 수 있다. 큰원판이 작은원판 위에 있으면 안된다.

N 개의 원반을 옮기기 위해서는 N-1개의 원반을 이웃한 기둥으로 옮겨야 합니다.
가장 큰 원반이 최종 목적 기둥으로 옮깁니다.
이제 이웃한 기둥에서 n-1개의 원반을 최종 목적 기둥으로 옮겨야 합니다.

# Generic
class Person<T extends Animal>{
    public T info;
}



##############
# PCCP
##############
# 외톨이 수
in : edeaaabbccd 
out : de

##############
# 코딩테스트 Java 문법
##############
# Integer Array <> int Array 변환
Integer[] integerArr = Arrays.stream(intArr).boxed().toArray(Integer[]::new);
int[] intArr = Arrays.stream(integerArr).mapToInt(Integer::intValue).toArray();
# Array to List
List<Integer> intList = Arrays.asList(integerArr);
# compare 
class StuScore implements Comparable<StuScore>{
	public int compareTo(StuScore other){return this.score - other.score;}
}
# mod 연산은 덧셈, 뺄셈, 나눗셈에 대해서 분배법칙이 성립된다.
(a * b) % c == (a%c * b%c) % c;
# 에라토스테네스 체
소수 : 1과 자기 자신 이외에는 나누어지지 않는 수, 소수 판별은 2부터 자기 자신 -1 까지 다 나누어 봐서 나머지가 0이 아닌것으로 알 수 있지만, 
루트씌운 제곱근 값 까지만 나누어 봐도 된다.  Math.sqrt(N) / i != 0 ==> 배열만들어서 배수 다 체크하고 건너뛰면서 따로 나누는것 하지 않아야 한다.

# Arrays.stream()
int min = Arrays.stream(arr).min().getAsInt();
int max = Arrays.stream(arr).max().getAsInt();
int sum = Arrays.stream(arr).sum();

##############
# 강의 사이트 모의고사 사이트
##############
# leet code https://leetcode.com/

3C2 조합 resList(3) : [AB, AC, BC]
3C2 중복조합 resList(6) : [AA, AB, AC, BB, BC, CC]
3P2 순열 resList(6) : [AB, AC, BA, BC, CA, CB]
3P2 중복순열 resList(9) : [AA, AB, AC, BA, BB, BC, CA, CB, CC]


3P2 조합 부분집합 resList(6) : [A, AB, AC, B, BC, C]
3P2 중복조합 resList(9) :         [A, AA, AB, AC, B, BB, BC, C, CC]
3P2 순열 부분집합 resList(9) : [A, AB, AC, B, BA, BC, C, CA, CB]
3P2 중복순열 부분집합 resList(12) : [A, AA, AB, AC, B, BA, BB, BC, C, CA, CB, CC]

2023-05-27 토요일
# LeetCode - rooms & keys : 간단한 탐색
# LeetCode - Connected Components : 엣지를 --> 노드별 연결 목록 으로 변경해서
# MergeSort


2023-06-03 토요일
--------------------------------
Infrun Ch.1 문자열 
--------------------------------
5. 특정 문자 뒤집기
	문자 뒤집기 할 때 left++ 인덱스 right-- 인덱스로 Swap 할 수 있음
7. 회문 문자열
	문자 대칭인지 확인 할 때는  mid 값 까지만 반대편과 검사 하면 된다.
8. 유효한 팰린드롬
	문자 뒤집을 때 StringBuilder.reverse() 하면 간단하게 뒤집을 수 있음.
9. 숫자만 추출
	문자를 숫자로 바꿀 때 num = (num * 10) + (ch - '0') 으로 앞에서부터 읽어 나가면서 숫자를 만들 수 있음
10. 가장 짧은 문자거리
	내가 푼 방법 : 이중 루프로 문자마다 다시 문자열 길이만큼 루프돌면서 앞뒤칸 옮겨 가며 찾았으나
	더 좋은 방법 : 배열하나 놓고, 왼쪽으로 같은 문자면 0, 다른문자면 거리++ 하면서 한번 쭉 돌고, 다시 오른쪽으로 한번더해서 더 작은값
11. 문자열압축하기
	내가 푼 방법 : 인덱스 이전값과 비교해서 사후에 넣었으나
	더 좋은 방법 : 문자열 맨 뒤에 임시공백문자 하나 붙인 후, 인덱스를 문자열 길이 -1 까지 돌리면서, 인덱스 다음것 비교한다.
12. 문자열이진수값
	Integer.parseInt(str, 2) 하면 2진수로 파싱

--------------------------------
Infrun Ch2. 배열, 숫자
--------------------------------

4. 피보나치 수열
	변수 a, b, c 로 밀어내는 방법으로 재귀, 배열 없이도 가능
5. 소수(에라토스테네스 체)
	배열만들어서 배수 다 체크하고 건너뛰면서 따로 나누는것 하지 않아야 한다.
6. 뒤집은 소수
	숫자 뒤집는 방법은 1. 캐릭터배열로 num = (num * 10) + (ch[j] - '0') 하는 방법이외에도
	2. 숫자만으로 하는 방법
	while(tmp > 0){
		num = (num * 10) + (tmp % 10);
		tmp = tmp / 10; 
	}

8. 등수구하기
	내가 한 방식은 sort 한 후 루프돌면서 이전 점수와 다르면 그 점수를 가지고 있는 등수를 update 하는 방식이었지만,
	간단하게 이중 루프로 i 번째의 점수에 대해 전체점수를 보면 큰 카운트를 세어서 결과 배열에 세팅하는 방법이 있다.

9. 배열 격자 최대 합
	내가 한 방법은 이중루프안에서 i==j 일때 lCross, i+j = N-1 일때 rCross 했으나
	별도로 일중루프 돌면서 lCros += arr[i][i], rCros += arr[i][N-1 -i] 하는방법이 있다.

11. 임시반장 정하기
	문제를 잘 읽어야 한다. 한번 같은반이었던 친구를 다음학년에 같은 반이었다고 해서 다시 카운트 하면 안된다.
	그렇기 때문에 i-학생 j-학년 k-학생으로 루프돌면 안되고, i-학생 j-학생 k-학년으로 루프 돌아야 한다.

12. 멘토링
	내가 한 방식은 배열을 이용해 모든 가능수를 true 한 후 시험 회차마다 돌며 멘티가 안되는 조건을 제거해가는 방식이었지만,
	강사 방식은 4중루프로 맨토-맨티에 대해서 시험별 학생점수를 찾아서 만족하는지 확인후 그게 전체회차수와 같으면 Count++ 방식

--------------------------------
Infrun Ch3.Two pointers, Sliding window[효율성 : O(n^2)-->O(n)]
--------------------------------
3. 최대 매출
	연속된 구간 합 구할 때 내가 한 방식은 매번 i에 대해 K일 동안 루프를 더하며 sum을 구했으나
	강사 방식은 최초 한번만 0부터K-1 까지 구하고, 그 다음부터는 한칸씩 밀면서 (i-1)

4. 연속 부분수열
	우선 조합, 순열 생각해보았으나 잘 되지 않았고, 이중루프 돌렸더니 시간초과였고, 다시 시도해서 투포인터 + 비교 하는 방식으로 했음
	강사 방식도 투포인터, for 문에서는 sum += arr[rt] 한후, while(sum >= M) 한것임. 마지막값이 M 과 같을때를 잘 고려해야 함
6. 최대 길이 연속부분수열
	나는 실패. 투포인터로 가면서 0/1 판단후 0이면 K만큼 쓸수있는 찬스를 사용했는지 여부를 봐서 sum 감소 시키려 했으나 실패
	연속된 길이 : rt - lt +1 하고, rt는 항상 0 을 만나면 1로 바꾸고, lt 는 다음번 0 다음을 가리킴. 1다 지나간 후 0에서 찬스 지우고 다음칸 가있음.
	찬스 쓰고 증가.

--------------------------------
Infrun Ch4.HashMap, TreeSet (해쉬, 정렬지원 Set)
--------------------------------
2. 아나그램
	나는 별도 루프돌려서 map1, map2 를 비교했지만
	강사방식은 : map1 만들어 놓은 후에   char c 에 대해서 
	if(!map1.containsKey(c) || map1.get(c) == 0) return flase; 
	map1.put(c, map1.get(c) -1);

3. 모든매출액의 종류
	슬라이드 윈도우 + map 문제, map.size() 로 판단 할것이면, 카운트 -1 해준후 카운트가 0이면 map.remove() 해줘야 한다. 배열인덱스 주의

4. 모든 아나그램 찾기
	나는 map1, map2 만들고 str 에 대해서 슬라이딩 윈도우로 돌면서 map2 루프문으로 비교했지만
	강사방식은 - map1 에 value 0 이면 remove 하고 map1.equls(map2) 로 편하게 비교했음

5. K번째 큰 수
	나는 조합 재귀함수에서 HashSet 사용, 다시 ArrayList 에 넣고 Collections.sort 했지만
	강사방식은 - 3중 for 문에서 TreeSet 에 Collections.reverseOrder() 사용 이후 for 에서 K번째 리턴

--------------------------------
Infrun Ch5.Stack, Queue(자료구조)
--------------------------------
4. 후위식 연산(postfix)
	내가 실수한 것은 Stack 에서 꺼냈을 때 '+', '*' 는 순서에 상관 없지만, '-', '/'는 stack 에서 두번째 pop 한 값에서 첫번째 pop 한 값을 -, / 연산 해야 한다.
	중위식을 후위식으로 변경하는 방법 1.숫자 : 큐 offer, 2.여는괄호 : 스텍 push, 3.닫는괄호 : 여는괄호나올때까지 pop 하고 큐 offer, 
	4. 연산자는 현재것보다 우선순위 높거나 같은것 모두 스텍 pop 에서 큐 offer, 현재것 스텍에 pop (연산자 우선순위 - 3:'*','/', 2:'+','-', 1:'(')
	5. 루프 종료 후 스텍 pop 에서 큐 offer 

5. 쇠막대기
	나는 "()" 를 레이저로 보고 "1" 로 replaceAll 한 후에 ')' 를 만나면 '(' 를 만날때까지의 레이저 카운트+1 을 누적하는 방식이었지만
	강사방식은 '(' 무조건 스텍에 넣고,
	')' 만났을 때 바로이전토큰이 '(' 였으면 레이저로 : pop 한 후  answer += stack.size()
	바로 이전토큰이 '(' 이 아니었다면 막대기 끝 자투리 :  pop 한 후 answer += 1 해주는 방식

6. 공주 구하기
	처음 실수한것은 : K번째여서 뺀 경우 idx 를 그대로 두고 list.size() 와 같으면 0 으로 하고, 빼지 않은 경우는 그냥 idx++ 한 후에  list.size() 와 같으면 0 으로 해야 한다.
	하지만 강사방식은 : i % K != 0 일때는 queue.offer(queue.poll()); 로 순환, 만약 K번째일 때는 queue.poll() 로 비워 버린다.

--------------------------------
Infrun Ch-6.Sorting and Searching(정렬, 이분검색과 결정알고리즘)
--------------------------------
3. 삽입정렬
	삽입정렬은 이중루프 안에서 정렬부분을 늘라가는 방식으로 i 번째 대상 시  j=i-1 부터 시작해서 arr[j] > arr[i]의값이 작은동안 arr[j+1] = arr[j]로 쉬프트 후 루프 종료하면 arr[j+1] = arr[i] 로 삽입

9. 뮤직비디오(결정알고리즘)
	나는 가능한 capacity를 0부터 무제한으로 돌려가며 최소의 가능한 값을 찾아서 break 로 리턴했으나
	강사방식은 capacity에 대해서 필요한 dvd 수를 리턴하는 함수를 두고, 이진탐색으로 범위 좁혀가며 탐색

10. 마구간 정하기(결정알고리즘)
	결정알고리즘은 답이 될 수 있는 후보를 역으로 넣어서 조건에 부합되는지를 확인후 이분탐색으로 범위 좁혀나간다.
	C개의말들이 사이가 최대한멀게 들어갈수있는 최대거리 --> 거리를 가지고 몇개의 말들이 들어갈 수 있는지로 판단.


--------------------------------
Infrun Ch-7. Recursive, Tree, Graph(DFS, BFS 기초)
--------------------------------
7. 이진트리 레벨탐색(BFS : Breadth-First Search)
	레벨 찾을 때  1단에 while(!Q.isEmpty()) 하나 걸고, len = Q.size() 구해서 2단에 Queue 에있는 것 다 꺼내고 level++ 해주면 몇레벨에 탐색했는지 알 수 있음.
	3단은 자식노드 Queue 에 offer()
8. 송아지 찾기1(BFS)
	BFS 로 찾되, visited[] 배열 사용하지 않으면 시간초과 발생
14. 그래프 최단거리(BFS)
	BFS  경로거리 구할 때 lv 을 사용하는 방법외에 resArr[nv] = resArr[cv]+1; 하는 방법이 있음.
--------------------------------
Infrun Ch-8. DFS, BFS 활용
--------------------------------
1. 합이 같은 부분집합
	나는 조합으로 부분집합들을 구해서 sum(arr) - sum(list) == sum(list) 의 조건으로 구했음.
	강사방식은 DFS를 약간 다른 방식 "포함한다", "포함하지않는다" 방식으로 찾았음.
2. 바둑이 승차
3. 최대점수 구하기
4. 중복순열(채점지원안됨)
5. 동전교환
6. 순열 구하기(채점지원안됨)
7. 조합수(메모이제이션)
	조합수는 nCr =   (n-1 C r-1) +  (n-1 C r) 이고, 이런것은 이차원배열을 통해 메모라이제이션 해야한다.
8. 수열 추측하기
	N개의 윗자리의수에 대해서 아랫칸은 위 두 수를 중첩해서 만들어서 가장 아래 내려오는 경우
	1, 2, 3, 4 라면  1: 1개, 2:3개, 3:3개, 4:1개  즉 1: 3C0,  2: 3C1,  3: 3C2,  4: 3C1 이다 여기서 3은 N-1 임.
9. 조합 구하기(채점지원안됨)
10. 미로탐색(DFS)
	0 1 미로찾기는  2차원배열 만들고  dx, dy 로 nx, ny 구해서 범위안에 있고, 1 이 아닌 경우 간다.
	지나간 길은 1 로 체크하고 DFS() 한 후에 재귀 아래서 0으로 체크 푼다. 
	최초 1, 1 지점 DFS() 호출할 때 1 로 체크 하고 가야 한다.
11. 미로의 최단거리 통로(BFS)
12. 토마토(BFS)
13. 섬나라 아일랜드(DFS)
14. 섬나라 아일랜드(BFS)
15. 피자배달거리(DFS)
--------------------------------
Infrun Ch-9. Greedy Algorithm
--------------------------------
1. 씨름선수
2. 회의실 배정
3. 결혼식
4. 최대수입스케쥴( PriorityQueue)
5. 다익스트라 알고리즘(채점지원안됨)
6. 친구인가(Uion&Find 알고리즘)
7. 원더랜드(최소 스패닝 트리 - 크루스칼 : Uion&Find 이용)
8. 원더랜드(최소 스패닝 트리 - 프림 : PriorityQueue 활용)

--------------------------------
Infrun Ch-10. dynamic programming(동적계획법)
--------------------------------
1. 계단오르기
2. 돌다리 건너기
3. 최대부분증가수열(LIS)
4. 가장 높은 탑 쌓기(LIS 응용)
5. 동전교환(냅색 알고리즘)
6. 최대점수 구하기(냅색알고리즘)

