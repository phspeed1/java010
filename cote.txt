
# 재귀 (Recursive)
재귀함수는 콜스택에 쌓인다. 재귀함수 앞부분은 순방향, 뒷부분은 역방향으로 실행된다.
선언적 프로그램, 종료조건 필수.

# 정렬 (Sort)
* Selection Sort : 배열에서 가장 작은수를 찾아서 제일 앞부분으로 swap
* Bubble Sort : n 과 n+1 인덱스의 수를 비교해서 swap 제일 큰수를 제일 끝으로 밀어낸다.
* Merge Sort 
 . 각각 정렬된 두개의 배열을 merge 하면서 정렬
 . 시작인덱스, 마지막인덱스를 받아서 배열을 반으로 나눠서 2번 mergeSort() 재귀 호출
 . 재귀함수가 돌아왔을 때는 가운데를 기준으로 왼쪽, 오른쪽이 정렬되어있는 상태이므로  merge() 호출해서 두개의 배열을 병합
 . 병합할 때는 원본을 임시배열에 복사한 후 각각 idx 를 가지고 작은것부터 채워주되, 만약 start 쪽 배열이 다 차지 않았으면 채워준다.
* Quick Sort
 . pivot 값을 기준으로 작은파티션 큰파티션으로 나누는 것을 반복
 . swap 이용

# 탐색(DFS, BFS)
DFS 는 Stack 또는 콜스텍 이용
BFS 는 Queue 또는 루프문 이용
노드 길이 만큼 visited 배열이나 hash 만들어서 이미 이동한곳은 가지 않도록 하면서 재귀 호출
만약 노드별 연결노드 목록이 아닌  엣지 리스트가 온다면 List<Integer>[] adjacencyList = new ArrayList[NodeCnt]; 배열을 만들어 사용
List<List<Integer>> retrivedResult = new ArrayList<>(); 로 탐색 덩어리별로 담을 수 있음


# 순열(permutation)
만들어내야하는조합 즉 arr.length 만큼 왔으면 재귀호출 종료하고, 결과 목록에 만든 조합을 add
후보 즉 arr 에서 하나씩 꺼내서 이미 조합된배열에 있지 않으면 조합에 꺼낸것을 넣고, 재귀호출해서 다음 레벨로 이동
재귀호출이 끝나서 콜스텍에서 꺼내질 때는 마지막에 넣은 것을 빼주어야 한다.

# 조합(Combination)
순열은 {A, B} 와 {B, A} 가 다른 것이지만, 조합은 {A, B} 와 {B, A} 가 같다. 즉 순서 무시

# DP (Dynamic Programming)
피보나치수열을 배열을 이용한 DP 를 이용하면 콜스택도 덜 사용하고 속도도 좋음.

# util
System.out.println("배열출력 : "+Arrays.toString(array));
Arrys.copyof() 로 배열 copy


Arrays.sort(charArray); // char[] 정렬
Arrays.sort(CharacterArray, Collections.reverseOrder()); // Character[] 내림정렬
hashMap.getOrDefault(key, defaultValue);

List<List<Integer>> result = new ArrayList<>();
List<Integer>[] nodeList = new ArrayList[n];

Stack : push(), pop()
Queue : new LinkedList(), offer(), pull()

##############
# Gejava
##############
# 피보나치 수열
n = n-1 + n-2 

# 하노이의 탑
세개의 기둥이 있다. 하기둥에 밑에서부터 위로 큰원판에서 작은원판이 순서대로 쌓여있다.
한번에 하나의 원판만 옮길 수 있다. 큰원판이 작은원판 위에 있으면 안된다.

N 개의 원반을 옮기기 위해서는 N-1개의 원반을 이웃한 기둥으로 옮겨야 합니다.
가장 큰 원반이 최종 목적 기둥으로 옮깁니다.
이제 이웃한 기둥에서 n-1개의 원반을 최종 목적 기둥으로 옮겨야 합니다.

# Generic
class Person<T extends Animal>{
    public T info;
}



##############
# PCCP
##############
# 외톨이 수
in : edeaaabbccd 
out : de

##############
# 코딩테스트 Java 문법
##############
# Integer Array <> int Array 변환
Integer[] integerArr = Arrays.stream(intArr).boxed().toArray(Integer[]::new);
int[] intArr = Arrays.stream(integerArr).mapToInt(Integer::intValue).toArray();
# Array to List
List<Integer> intList = Arrays.asList(integerArr);
# compare 
class StuScore implements Comparable<StuScore>{
	public int compareTo(StuScore other){return this.score - other.score;}
}
# mod 연산은 덧셈, 뺄셈, 나눗셈에 대해서 분배법칙이 성립된다.
(a * b) % c == (a%c * b%c) % c;
# 에라토스테네스 체
소수 : 1과 자기 자신 이외에는 나누어지지 않는 수, 소수 판별은 2부터 자기 자신 -1 까지 다 나누어 봐서 나머지가 0이 아닌것으로 알 수 있지만, 
루트씌운 제곱근 값 까지만 나누어 봐도 된다.  Math.sqrt(N) / i != 0 ==> 배열만들어서 배수 다 체크하고 건너뛰면서 따로 나누는것 하지 않아야 한다.

##############
# 강의 사이트 모의고사 사이트
##############
# leet code https://leetcode.com/

3C2 조합 resList(3) : [AB, AC, BC]
3C2 중복조합 resList(6) : [AA, AB, AC, BB, BC, CC]
3P2 순열 resList(6) : [AB, AC, BA, BC, CA, CB]
3P2 중복순열 resList(9) : [AA, AB, AC, BA, BB, BC, CA, CB, CC]


3P2 조합 부분집합 resList(6) : [A, AB, AC, B, BC, C]
3P2 중복조합 resList(9) :         [A, AA, AB, AC, B, BB, BC, C, CC]
3P2 순열 부분집합 resList(9) : [A, AB, AC, B, BA, BC, C, CA, CB]
3P2 중복순열 부분집합 resList(12) : [A, AA, AB, AC, B, BA, BB, BC, C, CA, CB, CC]

2023-05-27 토요일
# LeetCode - rooms & keys : 간단한 탐색
# LeetCode - Connected Components : 엣지를 --> 노드별 연결 목록 으로 변경해서
# MergeSort


2023-06-03 토요일
Infrun Ch.1 문자열 
5. 특정 문자 뒤집기
	문자 뒤집기 할 때 left++ 인덱스 right-- 인덱스로 Swap 할 수 있음
7. 회문 문자열
	문자 대칭인지 확인 할 때는  mid 값 까지만 반대편과 검사 하면 된다.
8. 유효한 팰린드롬
	문자 뒤집을 때 StringBuilder.reverse() 하면 간단하게 뒤집을 수 있음.
9. 숫자만 추출
	문자를 숫자로 바꿀 때 num = (num * 10) + (ch - '0') 으로 앞에서부터 읽어 나가면서 숫자를 만들 수 있음
10. 가장 짧은 문자거리
	내가 푼 방법 : 이중 루프로 문자마다 다시 문자열 길이만큼 루프돌면서 앞뒤칸 옮겨 가며 찾았으나
	더 좋은 방법 : 배열하나 놓고, 왼쪽으로 같은 문자면 0, 다른문자면 거리++ 하면서 한번 쭉 돌고, 다시 오른쪽으로 한번더해서 더 작은값
11. 문자열압축하기
	내가 푼 방법 : 인덱스 이전값과 비교해서 사후에 넣었으나
	더 좋은 방법 : 문자열 맨 뒤에 임시공백문자 하나 붙인 후, 인덱스를 문자열 길이 -1 까지 돌리면서, 인덱스 다음것 비교한다.
12. 문자열이진수값
	Integer.parseInt(str, 2) 하면 2진수로 파싱

Infrun Ch2. 배열, 숫자

4. 피보나치 수열
	변수 a, b, c 로 밀어내는 방법으로 재귀, 배열 없이도 가능
5. 소수(에라토스테네스 체)
	배열만들어서 배수 다 체크하고 건너뛰면서 따로 나누는것 하지 않아야 한다.
6. 뒤집은 소수
	숫자 뒤집는 방법은 1. 캐릭터배열로 num = (num * 10) + (ch[j] - '0') 하는 방법이외에도
	2. 숫자만으로 하는 방법
	while(tmp > 0){
		num = (num * 10) + (tmp % 10);
		tmp = tmp / 10; 
	}

8. 등수구하기
	내가 한 방식은 sort 한 후 루프돌면서 이전 점수와 다르면 그 점수를 가지고 있는 등수를 update 하는 방식이었지만,
	간단하게 이중 루프로 i 번째의 점수에 대해 전체점수를 보면 큰 카운트를 세어서 결과 배열에 세팅하는 방법이 있다.

9. 배열 격자 최대 합
	내가 한 방법은 이중루프안에서 i==j 일때 lCross, i+j = N-1 일때 rCross 했으나
	별도로 일중루프 돌면서 lCros += arr[i][i], rCros += arr[i][N-1 -i] 하는방법이 있다.

11. 임시반장 정하기
	문제를 잘 읽어야 한다. 한번 같은반이었던 친구를 다음학년에 같은 반이었다고 해서 다시 카운트 하면 안된다.
	그렇기 때문에 i-학생 j-학년 k-학생으로 루프돌면 안되고, i-학생 j-학생 k-학년으로 루프 돌아야 한다.

12. 멘토링
	내가 한 방식은 배열을 이용해 모든 가능수를 true 한 후 시험 회차마다 돌며 멘티가 안되는 조건을 제거해가는 방식이었지만,
	강사 방식은 4중루프로 맨토-맨티에 대해서 시험별 학생점수를 찾아서 만족하는지 확인후 그게 전체회차수와 같으면 Count++ 방식

Infrun Ch3.Two pointers, Sliding window[효율성 : O(n^2)-->O(n)]
3. 최대 매출
	연속된 구간 합 구할 때 내가 한 방식은 매번 i에 대해 K일 동안 루프를 더하며 sum을 구했으나
	강사 방식은 최초 한번만 0부터K-1 까지 구하고, 그 다음부터는 한칸씩 밀면서 (i-1)

4. 연속 부분수열
	우선 조합, 순열 생각해보았으나 잘 되지 않았고, 이중루프 돌렸더니 시간초과였고, 다시 시도해서 투포인터 + 비교 하는 방식으로 했음
	강사 방식도 투포인터, for 문에서는 sum += arr[rt] 한후, while(sum >= M) 한것임. 마지막값이 M 과 같을때를 잘 고려해야 함
6. 최대 길이 연속부분수열
	나는 실패. 투포인터로 가면서 0/1 판단후 0이면 K만큼 쓸수있는 찬스를 사용했는지 여부를 봐서 sum 감소 시키려 했으나 실패
	연속된 길이 : rt - lt +1 하고, rt는 항상 0 을 만나면 1로 바꾸고, lt 는 다음번 0 다음을 가리킴. 1다 지나간 후 0에서 찬스 지우고 다음칸 가있음.
	찬스 쓰고 증가.

Infrun Ch4.HashMap, TreeSet (해쉬, 정렬지원 Set)
2. 아나그램
	나는 별도 루프돌려서 map1, map2 를 비교했지만
	강사방식은 : map1 만들어 놓은 후에   char c 에 대해서 
	if(!map1.containsKey(c) || map1.get(c) == 0) return flase; 
	map1.put(c, map1.get(c) -1);

3. 모든매출액의 종류
	슬라이드 윈도우 + map 문제, map.size() 로 판단 할것이면, 카운트 -1 해준후 카운트가 0이면 map.remove() 해줘야 한다. 배열인덱스 주의

4. 모든 아나그램 찾기
	나는 map1, map2 만들고 str 에 대해서 슬라이딩 윈도우로 돌면서 map2 루프문으로 비교했지만
	강사방식은 - map1 에 value 0 이면 remove 하고 map1.equls(map2) 로 편하게 비교했음

5. K번째 큰 수
	나는 조합 재귀함수에서 HashSet 사용, 다시 ArrayList 에 넣고 Collections.sort 했지만
	강사방식은 - 3중 for 문에서 TreeSet 에 Collections.reverseOrder() 사용 이후 for 에서 K번째 리턴