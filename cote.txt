
# 재귀 (Recursive)
재귀함수는 콜스택에 쌓인다. 재귀함수 앞부분은 순방향, 뒷부분은 역방향으로 실행된다.
선언적 프로그램, 종료조건 필수.

# 정렬 (Sort)
* Selection Sort : 배열에서 가장 작은수를 찾아서 제일 앞부분으로 swap
* Bubble Sort : n 과 n+1 인덱스의 수를 비교해서 swap 제일 큰수를 제일 끝으로 밀어낸다.
* Merge Sort 
 . 각각 정렬된 두개의 배열을 merge 하면서 정렬
 . 시작인덱스, 마지막인덱스를 받아서 배열을 반으로 나눠서 2번 mergeSort() 재귀 호출
 . 재귀함수가 돌아왔을 때는 가운데를 기준으로 왼쪽, 오른쪽이 정렬되어있는 상태이므로  merge() 호출해서 두개의 배열을 병합
 . 병합할 때는 원본을 임시배열에 복사한 후 각각 idx 를 가지고 작은것부터 채워주되, 만약 start 쪽 배열이 다 차지 않았으면 채워준다.
* Quick Sort
 . pivot 값을 기준으로 작은파티션 큰파티션으로 나누는 것을 반복
 . swap 이용
 * Insert Sort
 . 내 앞의수는 정렬이 되있다고 가정, i 와 한칸 앞에서부터 j-- 와 비교해서 j값이 i값보다 크면 우측으로 한칸 Shift

# 탐색(DFS, BFS)
DFS 는 Stack 또는 콜스텍 이용
BFS 는 Queue 또는 루프문 이용
노드 길이 만큼 visited 배열이나 hash 만들어서 이미 이동한곳은 가지 않도록 하면서 재귀 호출
만약 노드별 연결노드 목록이 아닌  엣지 리스트가 온다면 List<Integer>[] adjacencyList = new ArrayList[NodeCnt]; 배열을 만들어 사용
List<List<Integer>> retrivedResult = new ArrayList<>(); 로 탐색 덩어리별로 담을 수 있음


# 순열(permutation)
만들어내야하는조합 즉 arr.length 만큼 왔으면 재귀호출 종료하고, 결과 목록에 만든 조합을 add
후보 즉 arr 에서 하나씩 꺼내서 이미 조합된배열에 있지 않으면 조합에 꺼낸것을 넣고, 재귀호출해서 다음 레벨로 이동
재귀호출이 끝나서 콜스텍에서 꺼내질 때는 마지막에 넣은 것을 빼주어야 한다.

# 조합(Combination)
순열은 {A, B} 와 {B, A} 가 다른 것이지만, 조합은 {A, B} 와 {B, A} 가 같다. 즉 순서 무시

# DP (Dynamic Programming)
피보나치수열을 배열을 이용한 DP 를 이용하면 콜스택도 덜 사용하고 속도도 좋음.

# util
System.out.println("배열출력 : "+Arrays.toString(array));
Arrys.copyof() 로 배열 copy


Arrays.sort(charArray); // char[] 정렬
Arrays.sort(CharacterArray, Collections.reverseOrder()); // Character[] 내림정렬
hashMap.getOrDefault(key, defaultValue);

List<List<Integer>> result = new ArrayList<>();
List<Integer>[] nodeList = new ArrayList[n];

Stack : push(), pop()
Queue : new LinkedList(), offer(), pull()

##############
# Gejava
##############
# 피보나치 수열
n = n-1 + n-2 

# 하노이의 탑
세개의 기둥이 있다. 하기둥에 밑에서부터 위로 큰원판에서 작은원판이 순서대로 쌓여있다.
한번에 하나의 원판만 옮길 수 있다. 큰원판이 작은원판 위에 있으면 안된다.

N 개의 원반을 옮기기 위해서는 N-1개의 원반을 이웃한 기둥으로 옮겨야 합니다.
가장 큰 원반이 최종 목적 기둥으로 옮깁니다.
이제 이웃한 기둥에서 n-1개의 원반을 최종 목적 기둥으로 옮겨야 합니다.

# Generic
class Person<T extends Animal>{
    public T info;
}



##############
# PCCP
##############
# 외톨이 수
in : edeaaabbccd 
out : de

##############
# 코딩테스트 Java 문법
##############
# Integer Array <> int Array 변환
Integer[] integerArr = Arrays.stream(intArr).boxed().toArray(Integer[]::new);
int[] intArr = Arrays.stream(integerArr).mapToInt(Integer::intValue).toArray();
# Array to List
List<Integer> intList = Arrays.asList(integerArr);
# compare 
class StuScore implements Comparable<StuScore>{
	public int compareTo(StuScore other){return this.score - other.score;}
}
# mod 연산은 덧셈, 뺄셈, 나눗셈에 대해서 분배법칙이 성립된다.
(a * b) % c == (a%c * b%c) % c;
# 에라토스테네스 체
소수 : 1과 자기 자신 이외에는 나누어지지 않는 수, 소수 판별은 2부터 자기 자신 -1 까지 다 나누어 봐서 나머지가 0이 아닌것으로 알 수 있지만, 
루트씌운 제곱근 값 까지만 나누어 봐도 된다.  Math.sqrt(N) / i != 0 ==> 배열만들어서 배수 다 체크하고 건너뛰면서 따로 나누는것 하지 않아야 한다.

# Arrays.stream()
int min = Arrays.stream(arr).min().getAsInt();
int max = Arrays.stream(arr).max().getAsInt();
int sum = Arrays.stream(arr).sum();

##############
# 강의 사이트 모의고사 사이트
##############
# leet code https://leetcode.com/

3C2 조합 resList(3) : [AB, AC, BC]
3C2 중복조합 resList(6) : [AA, AB, AC, BB, BC, CC]
3P2 순열 resList(6) : [AB, AC, BA, BC, CA, CB]
3P2 중복순열 resList(9) : [AA, AB, AC, BA, BB, BC, CA, CB, CC]


3P2 조합 부분집합 resList(6) : [A, AB, AC, B, BC, C]
3P2 중복조합 resList(9) :         [A, AA, AB, AC, B, BB, BC, C, CC]
3P2 순열 부분집합 resList(9) : [A, AB, AC, B, BA, BC, C, CA, CB]
3P2 중복순열 부분집합 resList(12) : [A, AA, AB, AC, B, BA, BB, BC, C, CA, CB, CC]

2023-05-27 토요일
# LeetCode - rooms & keys : 간단한 탐색
# LeetCode - Connected Components : 엣지를 --> 노드별 연결 목록 으로 변경해서
# MergeSort


2023-06-03 토요일
--------------------------------
Infrun Ch.1 문자열 
--------------------------------
5. 특정 문자 뒤집기
	문자 뒤집기 할 때 left++ 인덱스 right-- 인덱스로 Swap 할 수 있음
7. 회문 문자열
	문자 대칭인지 확인 할 때는  mid 값 까지만 반대편과 검사 하면 된다.
8. 유효한 팰린드롬
	문자 뒤집을 때 StringBuilder.reverse() 하면 간단하게 뒤집을 수 있음.
9. 숫자만 추출
	문자를 숫자로 바꿀 때 num = (num * 10) + (ch - '0') 으로 앞에서부터 읽어 나가면서 숫자를 만들 수 있음
10. 가장 짧은 문자거리
	내가 푼 방법 : 이중 루프로 문자마다 다시 문자열 길이만큼 루프돌면서 앞뒤칸 옮겨 가며 찾았으나
	더 좋은 방법 : 배열하나 놓고, 왼쪽으로 같은 문자면 0, 다른문자면 거리++ 하면서 한번 쭉 돌고, 다시 오른쪽으로 한번더해서 더 작은값
11. 문자열압축하기
	내가 푼 방법 : 인덱스 이전값과 비교해서 사후에 넣었으나
	더 좋은 방법 : 문자열 맨 뒤에 임시공백문자 하나 붙인 후, 인덱스를 문자열 길이 -1 까지 돌리면서, 인덱스 다음것 비교한다.
12. 문자열이진수값
	Integer.parseInt(str, 2) 하면 2진수로 파싱

--------------------------------
Infrun Ch2. 배열, 숫자
--------------------------------

4. 피보나치 수열
	변수 a, b, c 로 밀어내는 방법으로 재귀, 배열 없이도 가능
5. 소수(에라토스테네스 체)
	배열만들어서 배수 다 체크하고 건너뛰면서 따로 나누는것 하지 않아야 한다.
6. 뒤집은 소수
	숫자 뒤집는 방법은 1. 캐릭터배열로 num = (num * 10) + (ch[j] - '0') 하는 방법이외에도
	2. 숫자만으로 하는 방법
	while(tmp > 0){
		num = (num * 10) + (tmp % 10);
		tmp = tmp / 10; 
	}

8. 등수구하기
	내가 한 방식은 sort 한 후 루프돌면서 이전 점수와 다르면 그 점수를 가지고 있는 등수를 update 하는 방식이었지만,
	간단하게 이중 루프로 i 번째의 점수에 대해 전체점수를 보면 큰 카운트를 세어서 결과 배열에 세팅하는 방법이 있다.

9. 배열 격자 최대 합
	내가 한 방법은 이중루프안에서 i==j 일때 lCross, i+j = N-1 일때 rCross 했으나
	별도로 일중루프 돌면서 lCros += arr[i][i], rCros += arr[i][N-1 -i] 하는방법이 있다.

11. 임시반장 정하기
	문제를 잘 읽어야 한다. 한번 같은반이었던 친구를 다음학년에 같은 반이었다고 해서 다시 카운트 하면 안된다.
	그렇기 때문에 i-학생 j-학년 k-학생으로 루프돌면 안되고, i-학생 j-학생 k-학년으로 루프 돌아야 한다.

12. 맨토링
	내가 한 방식은 배열을 이용해 모든 가능수를 true 한 후 시험 회차마다 돌며 멘티가 안되는 조건을 제거해가는 방식이었지만,
	강사 방식은 4중루프로 맨토-맨티에 대해서 시험별 학생점수를 찾아서 만족하는지 확인후 그게 전체회차수와 같으면 Count++ 방식

--------------------------------
Infrun Ch3.Two pointers, Sliding window[효율성 : O(n^2)-->O(n)]
--------------------------------
3. 최대 매출
	연속된 구간 합 구할 때 내가 한 방식은 매번 i에 대해 K일 동안 루프를 더하며 sum을 구했으나
	강사 방식은 최초 한번만 0부터K-1 까지 구하고, 그 다음부터는 한칸씩 밀면서 (i-1)

4. 연속 부분수열
	우선 조합, 순열 생각해보았으나 잘 되지 않았고, 이중루프 돌렸더니 시간초과였고, 다시 시도해서 투포인터 + 비교 하는 방식으로 했음
	강사 방식도 투포인터, for 문에서는 sum += arr[rt] 한후, while(sum >= M) 한것임. 마지막값이 M 과 같을때를 잘 고려해야 함
6. 최대 길이 연속부분수열
	나는 실패. 투포인터로 가면서 0/1 판단후 0이면 K만큼 쓸수있는 찬스를 사용했는지 여부를 봐서 sum 감소 시키려 했으나 실패
	연속된 길이 : rt - lt +1 하고, rt는 항상 0 을 만나면 1로 바꾸고, lt 는 다음번 0 다음을 가리킴. 1다 지나간 후 0에서 찬스 지우고 다음칸 가있음.
	찬스 쓰고 증가.

--------------------------------
Infrun Ch4.HashMap, TreeSet (해쉬, 정렬지원 Set)
--------------------------------
2. 아나그램
	나는 별도 루프돌려서 map1, map2 를 비교했지만
	강사방식은 : map1 만들어 놓은 후에   char c 에 대해서 
	if(!map1.containsKey(c) || map1.get(c) == 0) return flase; 
	map1.put(c, map1.get(c) -1);

3. 모든매출액의 종류
	슬라이드 윈도우 + map 문제, map.size() 로 판단 할것이면, 카운트 -1 해준후 카운트가 0이면 map.remove() 해줘야 한다. 배열인덱스 주의

4. 모든 아나그램 찾기
	나는 map1, map2 만들고 str 에 대해서 슬라이딩 윈도우로 돌면서 map2 루프문으로 비교했지만
	강사방식은 - map1 에 value 0 이면 remove 하고 map1.equls(map2) 로 편하게 비교했음

5. K번째 큰 수
	나는 조합 재귀함수에서 HashSet 사용, 다시 ArrayList 에 넣고 Collections.sort 했지만
	강사방식은 - 3중 for 문에서 TreeSet 에 Collections.reverseOrder() 사용 이후 for 에서 K번째 리턴

--------------------------------
Infrun Ch5.Stack, Queue(자료구조)
--------------------------------
4. 후위식 연산(postfix)
	내가 실수한 것은 Stack 에서 꺼냈을 때 '+', '*' 는 순서에 상관 없지만, '-', '/'는 stack 에서 두번째 pop 한 값에서 첫번째 pop 한 값을 -, / 연산 해야 한다.
	중위식을 후위식으로 변경하는 방법 1.숫자 : 큐 offer, 2.여는괄호 : 스텍 push, 3.닫는괄호 : 여는괄호나올때까지 pop 하고 큐 offer, 
	4. 연산자는 현재것보다 우선순위 높거나 같은것 모두 스텍 pop 에서 큐 offer, 현재것 스텍에 pop (연산자 우선순위 - 3:'*','/', 2:'+','-', 1:'(')
	5. 루프 종료 후 스텍 pop 에서 큐 offer 

5. 쇠막대기
	나는 "()" 를 레이저로 보고 "1" 로 replaceAll 한 후에 ')' 를 만나면 '(' 를 만날때까지의 레이저 카운트+1 을 누적하는 방식이었지만
	강사방식은 '(' 무조건 스텍에 넣고,
	')' 만났을 때 바로이전토큰이 '(' 였으면 레이저로 : pop 한 후  answer += stack.size()
	바로 이전토큰이 '(' 이 아니었다면 막대기 끝 자투리 :  pop 한 후 answer += 1 해주는 방식

6. 공주 구하기
	처음 실수한것은 : K번째여서 뺀 경우 idx 를 그대로 두고 list.size() 와 같으면 0 으로 하고, 빼지 않은 경우는 그냥 idx++ 한 후에  list.size() 와 같으면 0 으로 해야 한다.
	하지만 강사방식은 : i % K != 0 일때는 queue.offer(queue.poll()); 로 순환, 만약 K번째일 때는 queue.poll() 로 비워 버린다.

--------------------------------
Infrun Ch-6.Sorting and Searching(정렬, 이분검색과 결정알고리즘)
--------------------------------
3. 삽입정렬
	삽입정렬은 이중루프 안에서 정렬부분을 늘라가는 방식으로 i 번째 대상 시  j=i-1 부터 시작해서 arr[j] > arr[i]의값이 작은동안 arr[j+1] = arr[j]로 쉬프트 후 루프 종료하면 arr[j+1] = arr[i] 로 삽입

9. 뮤직비디오(결정알고리즘)
	나는 가능한 capacity를 0부터 무제한으로 돌려가며 최소의 가능한 값을 찾아서 break 로 리턴했으나
	강사방식은 capacity에 대해서 필요한 dvd 수를 리턴하는 함수를 두고, 이진탐색으로 범위 좁혀가며 탐색

10. 마구간 정하기(결정알고리즘)
	결정알고리즘은 답이 될 수 있는 후보를 역으로 넣어서 조건에 부합되는지를 확인후 이분탐색으로 범위 좁혀나간다.
	C개의말들이 사이가 최대한멀게 들어갈수있는 최대거리 --> 거리를 가지고 몇개의 말들이 들어갈 수 있는지로 판단.


--------------------------------
Infrun Ch-7. Recursive, Tree, Graph(DFS, BFS 기초)
--------------------------------
7. 이진트리 레벨탐색(BFS : Breadth-First Search)
	레벨 찾을 때  1단에 while(!Q.isEmpty()) 하나 걸고, len = Q.size() 구해서 2단에 Queue 에있는 것 다 꺼내고 level++ 해주면 몇레벨에 탐색했는지 알 수 있음.
	3단은 자식노드 Queue 에 offer()
8. 송아지 찾기1(BFS)
	BFS 로 찾되, visited[] 배열 사용하지 않으면 시간초과 발생
14. 그래프 최단거리(BFS)
	BFS  경로거리 구할 때 lv 을 사용하는 방법외에 resArr[nv] = resArr[cv]+1; 하는 방법이 있음.
--------------------------------
Infrun Ch-8. DFS, BFS 활용
--------------------------------
1. 합이 같은 부분집합
	나는 조합으로 부분집합들을 구해서 sum(arr) - sum(list) == sum(list) 의 조건으로 구했음.
	강사방식은 DFS를 약간 다른 방식 "포함한다", "포함하지않는다" 방식으로 찾았음.
2. 바둑이 승차
3. 최대점수 구하기
4. 중복순열(채점지원안됨)
5. 동전교환
6. 순열 구하기(채점지원안됨)
7. 조합수(메모이제이션)
	조합수는 nCr =   (n-1 C r-1) +  (n-1 C r) 이고, 이런것은 이차원배열을 통해 메모라이제이션 해야한다.
8. 수열 추측하기
	N개의 윗자리의수에 대해서 아랫칸은 위 두 수를 중첩해서 만들어서 가장 아래 내려오는 경우
	1, 2, 3, 4 라면  1: 1개, 2:3개, 3:3개, 4:1개  즉 1: 3C0,  2: 3C1,  3: 3C2,  4: 3C1 이다 여기서 3은 N-1 임.
9. 조합 구하기(채점지원안됨)
10. 미로탐색(DFS)
	0 1 미로찾기는  2차원배열 만들고  dx, dy 로 nx, ny 구해서 범위안에 있고, 1 이 아닌 경우 간다.
	지나간 길은 1 로 체크하고 DFS() 한 후에 재귀 아래서 0으로 체크 푼다. 
	최초 1, 1 지점 DFS() 호출할 때 1 로 체크 하고 가야 한다.
11. 미로의 최단거리 통로(BFS)
	나는 bfs 는 최단이 무조건 먼저니까 먼저 간길은 board 에 1로 체크 하고 다시 안가는 방식, 레벨lv 를 사용했음
	강사방식은 nx ny가 0이 아닐때만 가고, 가는길은 이전좌표+1로 간 거리(레벨)로 체크. 최후에 7,7 위치의 값 리턴
12. 토마토(BFS)
	나는 그냥 board 배열 하나쓰고, 앞 뒤로 루프로 이미모두익은것,  안익은것이 남아있는것을 찾고, max - 1을 리턴했는데, 

13. 섬나라 아일랜드(DFS)
14. 섬나라 아일랜드(BFS)
15. 피자배달거리(DFS)
	나는 6C4 의 조합을 구해서 BFS로 각 집별로 4개의 피자집놓고 최소거리 의 Sum 을 answer 와 MIN 으로 했음. 하지만 런타임에러.
	강사방식은 조합을 구하고, 피자집은 index 만 구한후에, 최소거리는 그냥 Math.abs(h.x - p.x) 로 구했음

--------------------------------
Infrun Ch-9. Greedy Algorithm
--------------------------------
1. 씨름선수
	나는 그냥 2중 for 문으로 풀었지만
	강사방식은 Time Limit 을 피하기 위해서  객체생성 후 키로 정렬 후 그다음부터는 몸무게만 보되, 몸무게는 자신의 무게가 자기 앞의 무게의 최대값보다 작다면 탈락
2. 회의실 배정
	나는 방법이 생각나지 않았음
	강사 방식은 회의가 빨리 끝나는 것부터 선택한다. 그래서 끝나는 시간 그리고 시작시간으로 정렬 후 다음부터는 선택된 회의의 끝시간 이후 시작하는 회의 선택 으로 이어간다.
3. 결혼식
	나는 시간 배열만들어서 ON제곱으로 풀었으나
	강사 방식은 시작시간 만나면 cnt++, end시간 만나면 cnt-- 하면서, cnt 변할때마다 answer = Math.max(answer, cnt) 로 . 주의 할것은 나가는 것 먼저 cnt-- 해줄 것
	내가 두번째 한 방식은 starts 배열 ends 배열 만든것인데, 강사방식은 ArrayList 하나에 시간과 'S' 시간과 'E' 를 쭉 넣고 E만났을 때 먼저 빼는 것 
4. 최대수입스케쥴( PriorityQueue)
	나는 문제 자체를 이해하지 못했음. --> 문제 이해 했음 3일째 까지 갈수있는게 (제일 큰 60) 이었다고 해도 계속 그 강의를 할 수는 없는 것이었음
	PriorityQueue 사용해서 날짜 내림차순 정렬 후 Max 날짜로부터 후보넣고 PriorityQueue 에서 가장큰것 꺼내고, 다음날짜 가능한것들 넣고, 또 가장큰것 꺼내고
	중요한것은, 강의가 5일내 2개 3일내 2개  이렇게 있다면, 4일째에도 강의를 할 수 있다는 것이다. --> 때문에 정렬된 maxDays부터 1일까지 루프돌면서 매일 하나씩 꺼낸다.
	pQueue에 offer() 하는것은 list 에서 가리키는 index 에 있는 강의의 days 가 i일 보다 크거나 같은것은 pQueue 에 offer() 한다.

5. 다익스트라 알고리즘(채점지원안됨)
	내가 한 방식은 시작노드에서 각 노드로 가는최소비용을 노드번호로 배열잡고, DFS 돌려서 시작노드에서 탐색하면서 연결노드까지 가는 비용합이 기존에 구해진 최소값보다 작으면 Update.
	강사 방식은 O(n)로 최초 시작노드에서 갈수있는 최소비용 dis 에 Update 후 시작노드는 완료체크, 이후부터 dis 에서 최소비용인인 노드 완료체크 후 갈수 있는 노드 dis Update 반복
	인데, 매번 가장노드값을 구하기 위해서 루프 돌리지 않고 PriorityQueue를 이용했음
6. 친구인가(Uion&Find 알고리즘)
	나는 그냥 BFS 로 했지만
	강사방식은 집합을 만든다. Find() 는 번호를 받으면 집합번호를 리턴(재귀), Union()은 두번호를 한집합으로 묶는다.
	최초 번호가 다 자기집합으로 초기화 하고 Union으로 묶으면 집합번호가 연결연결되어 같게된다. Find() 할 때 DP 처럼 저장하고 리턴하면 경로 압축이 된다.
	
7. 원더랜드(최소 스패닝 트리 - 크루스칼 : Uion&Find 이용)
	나는 다익스트라로 해서 실패. 다익스트라는 방향성이 있을 때만 사용 가능 한 것 같다
	강사방식은 크루스칼 알고리즘은 그리디알고리즘이다. v1, v2, cost 를 가지는 클래스를 list 에 넣은 후, cost 로 정렬후 선택한다.
	find(), union() 을 이욯해서 find() 해서 같은 그룹이 아닐때만 선택하고, 선택한것은 union() 으로 묶어준다.
	프림은 다익스트라와 유사한 그리디 알고리즘이다. 단지 dis 로 1번노드에서 몇번 노드까지 가는 비용을 계산하는 다익스트라와 달리
	비용오름차순 정렬된 상황에서 한번 간 노드는 더이상 가지 않는다.
8. 원더랜드(최소 스패닝 트리 - 프림 : PriorityQueue 활용)

--------------------------------
Infrun Ch-10. dynamic programming(동적계획법)
--------------------------------
1. 계단오르기
	dp : 커다란 문제를 직관적으로 쉽게 알수 있는 문제로 쪼갠 후 누적해서 더해나가며 풀기
2. 돌다리 건너기
3. 최대부분증가수열(LIS)
	dp[] 배열 선언해서 dp[0] = 1로 초기화 한 후, 이중루프 i 에 대해서 j는 i 앞쪽으로 보면서 arr[i] 보다 arr[j]가 작은 경우 Math.max() 한것에 +1 하면 그것이 그 항목을 마지막으로 하는 수의 최대 부분순열 개수 이다.

4. 가장 높은 탑 쌓기(LIS 응용)
	내가한 방식 : 우선 무게로 정렬 후 넓이를 가지고 내 앞단에 넓이가 i 보다 작은 j 중 이미 구해놓은 max height 를 가진 최대 + i 의 height 가 내가 가질 수 있는 최고 height --> 잘 안됨. 부분점수
	강사방식 : 우선 넓이로 정렬 후, 각벽돌별로 내가 최상단일 경우의 높이를 구해서 dp[] 에 저장한다. 내가 최상단일 경우는 내앞에서 나보다 무게가 많이나가는 벽돌이 조건이고, 그중 max 높이를 찾은후에 내 높이를 더한다.
5. 동전교환(냅색 알고리즘)
	내가한 방식 : DFS 로 하면 안됨
	dp배열을 이용해서 각 동전별로 금액까지 필요한 개수를 기록하되 dp[j] = Math.min(dp[j], dp[ j - coin[i] ]+1) 로 기존까지의 최소에 이동전을 1개 사용했을때 최소값이 되는것을 동적으로 구해나간다.
6. 최대점수 구하기(냅색알고리즘)
	내가한 방식 : DFS 로 하면 안됨
	무한한 동전에 냅색적용시 j 를 앞에서돌리지만, 유한한(한번만 사용하는) 문제풀이 를 적용할때는 중복 사용을 방지하기 위해 j 가 M 에서 문제풀이기본시간 까지만 돌아야 함.



2023-06-20
다시 풀어볼 문제
2-11. 임시반장 정하기
2-12. 맨토링
3-4. 연속 부분수열
3-6. 최대 길이 연속부분수열

6-9. 뮤직비디오
6-10. 마구간정하기
8-2. 바둑이승차
8-8. 수열추측하기(파스칼의삼각형)
8-14. 피자배달거리

9-5. 다익스트라 알고리즘
9-7. 원더랜드(크루스컬)
9-8. 원더랜드(프림)
10-4. 가장높은탑쌓기
10-6. 최대점수구하기


2-11. 임시반장 정하기
	문제를 잘 읽어야 한다. 한번 같은반이었던 친구를 다음학년에 같은 반이었다고 해서 다시 카운트 하면 안된다.
	그렇기 때문에 i-학생 j-학년 k-학생으로 루프돌면 안되고, i-학생 j-학생 k-학년으로 루프 돌아야 한다.

2-12. 맨토링
	내가 한 방식은 배열을 이용해 모든 가능수를 true 한 후 시험 회차마다 돌며 멘티가 안되는 조건을 제거해가는 방식이었지만,
	강사 방식은 4중루프로 맨토-맨티에 대해서 시험별 학생점수를 찾아서 만족하는지 확인후 그게 전체회차수와 같으면 Count++ 방식

3-4. 연속 부분수열
	강사 방식도 투포인터, for 문에서는 sum += arr[rt] 한후, while(sum >= M) 한것임. 마지막값이 M 과 같을때를 잘 고려해야 함

3-6. 최대 길이 연속부분수열
	나는 실패. 투포인터로 가면서 0/1 판단후 0이면 K만큼 쓸수있는 찬스를 사용했는지 여부를 봐서 sum 감소 시키려 했으나 실패
	연속된 길이 : rt - lt +1 하고, rt는 항상 0 을 만나면 1로 바꾸고, lt 는 다음번 0 다음을 가리킴. 1다 지나간 후 0에서 찬스 지우고 다음칸 가있음.
	찬스 쓰고 증가.

6-9. 뮤직비디오
	나는 가능한 capacity를 0부터 무제한으로 돌려가며 최소의 가능한 값을 찾아서 break 로 리턴했으나
	강사방식은 capacity에 대해서 필요한 dvd 수를 리턴하는 함수를 두고, 이진탐색으로 범위 좁혀가며 탐색

6-10. 마구간정하기
	결정알고리즘은 답이 될 수 있는 후보를 역으로 넣어서 조건에 부합되는지를 확인후 이분탐색으로 범위 좁혀나간다.
	C개의말들이 사이가 최대한멀게 들어갈수있는 최대거리 --> 거리를 가지고 몇개의 말들이 들어갈 수 있는지로 판단.

8-2. 바둑이승차
	강사방식은 DFS를 약간 다른 방식 "포함한다", "포함하지않는다" 방식으로 찾았음.

8-8. 수열추측하기(파스칼의삼각형)
	N개의 윗자리의수에 대해서 아랫칸은 위 두 수를 중첩해서 만들어서 가장 아래 내려오는 경우
	1, 2, 3, 4 라면  1: 1개, 2:3개, 3:3개, 4:1개  즉 1: 3C0,  2: 3C1,  3: 3C2,  4: 3C1 이다 여기서 3은 N-1 임.

8-14. 피자배달거리
	나는 6C4 의 조합을 구해서 BFS로 각 집별로 4개의 피자집놓고 최소거리 의 Sum 을 answer 와 MIN 으로 했음. 하지만 런타임에러.
	강사방식은 조합을 구하고, 피자집은 index 만 구한후에, 최소거리는 그냥 Math.abs(h.x - p.x) 로 구했음

9-5. 다익스트라 알고리즘
	내가 한 방식은 시작노드에서 각 노드로 가는최소비용을 노드번호로 배열잡고, DFS 돌려서 시작노드에서 탐색하면서 연결노드까지 가는 비용합이 기존에 구해진 최소값보다 작으면 Update.
	강사 방식은 O(n)로 최초 시작노드에서 갈수있는 최소비용 dis 에 Update 후 시작노드는 완료체크, 이후부터 dis 에서 최소비용인인 노드 완료체크 후 갈수 있는 노드 dis Update 반복
	인데, 매번 가장노드값을 구하기 위해서 루프 돌리지 않고 PriorityQueue를 이용했음

9-7. 원더랜드(크루스컬)
	나는 다익스트라로 해서 실패. 다익스트라는 방향성이 있을 때만 사용 가능 한 것 같다
	강사방식은 크루스칼 알고리즘은 그리디알고리즘이다. v1, v2, cost 를 가지는 클래스를 list 에 넣은 후, cost 로 정렬후 선택한다.
	find(), union() 을 이욯해서 find() 해서 같은 그룹이 아닐때만 선택하고, 선택한것은 union() 으로 묶어준다.
	프림은 다익스트라와 유사한 그리디 알고리즘이다. 단지 dis 로 1번노드에서 몇번 노드까지 가는 비용을 계산하는 다익스트라와 달리
	비용오름차순 정렬된 상황에서 한번 간 노드는 더이상 가지 않는다.

9-8. 원더랜드(프림)
	크루스컬과 유사하지만 v1 v2 가 아닌 v 하나만으로 노드만들고, find() union() 아닌 ch배열 사용. PriorityQueue를 사용하기 때문에 한vertex로 가는 최소 비용은 이미 밟고 지나갔다는 개념.

10-4. 가장높은탑쌓기
	내가한 방식 : 우선 무게로 정렬 후 넓이를 가지고 내 앞단에 넓이가 i 보다 작은 j 중 이미 구해놓은 max height 를 가진 최대 + i 의 height 가 내가 가질 수 있는 최고 height --> 잘 안됨. 부분점수
	강사방식 : 우선 넓이로 정렬 후, 각벽돌별로 내가 최상단일 경우의 높이를 구해서 dp[] 에 저장한다. 내가 최상단일 경우는 내앞에서 나보다 무게가 많이나가는 벽돌이 조건이고, 그중 max 높이를 찾은후에 내 높이를 더한다.

10-6. 최대점수구하기
	내가한 방식 : DFS 로 하면 안됨
	무한한 동전에 냅색적용시 j 를 앞에서돌리지만, 유한한(한번만 사용하는) 문제풀이 를 적용할때는 중복 사용을 방지하기 위해 j 가 M 에서 문제풀이기본시간 까지만 돌아야 함.
############################
## InfLearn : total 94
############################
Ch010_String\010_문자찾기
Ch010_String\020_대소문자변환
Ch010_String\030_문장속단어
Ch010_String\040_단어뒤집기
Ch010_String\050_특정문자뒤집기
Ch010_String\060_중복문자제거
Ch010_String\070_회문문자열
Ch010_String\080_유효한팰린드롬
Ch010_String\090_숫자만추출
Ch010_String\100_가장짧은문자거리
Ch010_String\110_문자열압축
Ch010_String\120_암호편지2진수
Ch020_Array\010_큰수출력하기
Ch020_Array\020_보이는학생
Ch020_Array\030_가위바위보
Ch020_Array\040_피보나치수열
Ch020_Array\050_소수(에라토스테네스 체)
Ch020_Array\060_뒤집은소수
Ch020_Array\070_점수계산
Ch020_Array\080_등수구하기
Ch020_Array\090_격자판최대합
Ch020_Array\100_봉우리
Ch020_Array\110_임시반장정하기
Ch020_Array\120_멘토링
Ch030_TwoPointer_SlidingWindow\010_두배열합치기
Ch030_TwoPointer_SlidingWindow\020_공통원소구하기
Ch030_TwoPointer_SlidingWindow\030_최대매출
Ch030_TwoPointer_SlidingWindow\040_연속부분수열
Ch030_TwoPointer_SlidingWindow\050_연속된자연수의합
Ch030_TwoPointer_SlidingWindow\060_최대길이연속부분수열
Ch040_HashMap_TreeSet\010_학급회장
Ch040_HashMap_TreeSet\020_아나그램
Ch040_HashMap_TreeSet\030_매출액의종류
Ch040_HashMap_TreeSet\040_모든아나그램찾기
Ch040_HashMap_TreeSet\050_K번째큰수
Ch050_Stack_Queue\010_올바른괄호
Ch050_Stack_Queue\020_괄호문자제거
Ch050_Stack_Queue\030_크레인인형뽑기
Ch050_Stack_Queue\040_후위식연산
Ch050_Stack_Queue\050_쇠막대기
Ch050_Stack_Queue\060_공주구하기
Ch050_Stack_Queue\070_교육과정설계
Ch050_Stack_Queue\080_응급실
Ch060_Sorting_Searching\010_선택정렬
Ch060_Sorting_Searching\020_버블정렬
Ch060_Sorting_Searching\030_삽입정렬
Ch060_Sorting_Searching\040_LeastRecentlyUsed
Ch060_Sorting_Searching\050_중복확인
Ch060_Sorting_Searching\070_좌표정렬
Ch060_Sorting_Searching\080_이분검색
Ch060_Sorting_Searching\090_뮤직비디오
Ch060_Sorting_Searching\100_마구간정하기
Ch070_Recursive_Tree_Graph\010_재귀함수
Ch070_Recursive_Tree_Graph\020_이진수 출력(재귀)
Ch070_Recursive_Tree_Graph\030_팩토리얼
Ch070_Recursive_Tree_Graph\040_피보나치 재귀
Ch070_Recursive_Tree_Graph\050_이진트리순회
Ch070_Recursive_Tree_Graph\060_부분집합구하기_DFS
Ch070_Recursive_Tree_Graph\070_이진트리순회_넓이우선탐색_레벨탐색
Ch070_Recursive_Tree_Graph\080_송아지찾기
Ch070_Recursive_Tree_Graph\090_Tree말단노드까지가장짧은경로
Ch070_Recursive_Tree_Graph\100_Tree말단노드까지가장짧은경로_DFS
Ch070_Recursive_Tree_Graph\120_경로탐색(DFS)
Ch070_Recursive_Tree_Graph\130_경로탐색(인접리스트)
Ch070_Recursive_Tree_Graph\140_그래프최단거리(BFS)
Ch080_DFS_BFS\010_합이같은부분집합
Ch080_DFS_BFS\020_바둑이승차
Ch080_DFS_BFS\030_최대점수구하기
Ch080_DFS_BFS\040_중복순열구하기
Ch080_DFS_BFS\050_동전교환
Ch080_DFS_BFS\060_순열구하기
Ch080_DFS_BFS\070_조합의경우수
Ch080_DFS_BFS\080_수열추측하기_파스칼의삼각형
Ch080_DFS_BFS\090_조합구하기
Ch080_DFS_BFS\100_미로탐색
Ch080_DFS_BFS\110_미로의최단거리통로
Ch080_DFS_BFS\120_토마토
Ch080_DFS_BFS\130_섬나라아일랜드
Ch080_DFS_BFS\135_섬나라아일랜드(DFS)
Ch080_DFS_BFS\140_피자배달거리
Ch090_Greedy\010_씨름선수
Ch090_Greedy\020_회의실배정
Ch090_Greedy\030_결혼식
Ch090_Greedy\040_최대수입스케쥴
Ch090_Greedy\050_다익스트라알고리즘
Ch090_Greedy\060_친구인가
Ch090_Greedy\070_원더랜드_크루스컬
Ch090_Greedy\080_원더랜드_프림
Ch100_Dynamic_Programming\010_계단오르기
Ch100_Dynamic_Programming\020_돌다리건너기
Ch100_Dynamic_Programming\030_최대부분증가수열
Ch100_Dynamic_Programming\040_가장높은탑쌓기
Ch100_Dynamic_Programming\050_동전교환
Ch100_Dynamic_Programming\060_최대점수구하기