
# 재귀 (Recursive)
재귀함수는 콜스택에 쌓인다. 재귀함수 앞부분은 순방향, 뒷부분은 역방향으로 실행된다.
선언적 프로그램, 종료조건 필수.

# 정렬 (Sort)
* Selection Sort : 배열에서 가장 작은수를 찾아서 제일 앞부분으로 swap
* Bubble Sort : n 과 n+1 인덱스의 수를 비교해서 swap 제일 큰수를 제일 끝으로 밀어낸다.
* Merge Sort 
 . 각각 정렬된 두개의 배열을 merge 하면서 정렬
 . 시작인덱스, 마지막인덱스를 받아서 배열을 반으로 나눠서 2번 mergeSort() 재귀 호출
 . 재귀함수가 돌아왔을 때는 가운데를 기준으로 왼쪽, 오른쪽이 정렬되어있는 상태이므로  merge() 호출해서 두개의 배열을 병합
 . 병합할 때는 원본을 임시배열에 복사한 후 각각 idx 를 가지고 작은것부터 채워주되, 만약 start 쪽 배열이 다 차지 않았으면 채워준다.
* Quick Sort
 . pivot 값을 기준으로 작은파티션 큰파티션으로 나누는 것을 반복
 . swap 이용

# 탐색(DFS, BFS)
DFS 는 Stack 또는 콜스텍 이용
BFS 는 Queue 또는 루프문 이용
노드 길이 만큼 visited 배열이나 hash 만들어서 이미 이동한곳은 가지 않도록 하면서 재귀 호출
만약 노드별 연결노드 목록이 아닌  엣지 리스트가 온다면 List<Integer>[] adjacencyList = new ArrayList[NodeCnt]; 배열을 만들어 사용
List<List<Integer>> retrivedResult = new ArrayList<>(); 로 탐색 덩어리별로 담을 수 있음


# 순열(permutation)
만들어내야하는조합 즉 arr.length 만큼 왔으면 재귀호출 종료하고, 결과 목록에 만든 조합을 add
후보 즉 arr 에서 하나씩 꺼내서 이미 조합된배열에 있지 않으면 조합에 꺼낸것을 넣고, 재귀호출해서 다음 레벨로 이동
재귀호출이 끝나서 콜스텍에서 꺼내질 때는 마지막에 넣은 것을 빼주어야 한다.

# 조합(Combination)
순열은 {A, B} 와 {B, A} 가 다른 것이지만, 조합은 {A, B} 와 {B, A} 가 같다. 즉 순서 무시

# DP (Dynamic Programming)
피보나치수열을 배열을 이용한 DP 를 이용하면 콜스택도 덜 사용하고 속도도 좋음.

# util
System.out.println("배열출력 : "+Arrays.toString(array));
Arrys.copyof() 로 배열 copy


Arrays.sort(charArray); // char[] 정렬
Arrays.sort(CharacterArray, Collections.reverseOrder()); // Character[] 내림정렬
hashMap.getOrDefault(key, defaultValue);

List<List<Integer>> result = new ArrayList<>();
List<Integer>[] nodeList = new ArrayList[n];

Stack : push(), pop()
Queue : new LinkedList(), offer(), pull()

##############
# Gejava
##############
# 피보나치 수열
n = n-1 + n-2 

# 하노이의 탑
세개의 기둥이 있다. 하기둥에 밑에서부터 위로 큰원판에서 작은원판이 순서대로 쌓여있다.
한번에 하나의 원판만 옮길 수 있다. 큰원판이 작은원판 위에 있으면 안된다.

N 개의 원반을 옮기기 위해서는 N-1개의 원반을 이웃한 기둥으로 옮겨야 합니다.
가장 큰 원반이 최종 목적 기둥으로 옮깁니다.
이제 이웃한 기둥에서 n-1개의 원반을 최종 목적 기둥으로 옮겨야 합니다.

# Generic
class Person<T extends Animal>{
    public T info;
}



##############
# PCCP
##############
# 외톨이 수
in : edeaaabbccd 
out : de

##############
# 코딩테스트 Java 문법
##############
# Integer Array <> int Array 변환
Integer[] integerArr = Arrays.stream(intArr).boxed().toArray(Integer[]::new);
int[] intArr = Arrays.stream(integerArr).mapToInt(Integer::intValue).toArray();
# Array to List
List<Integer> intList = Arrays.asList(integerArr);
# compare 
class StuScore implements Comparable<StuScore>{
	public int compareTo(StuScore other){return this.score - other.score;}
}
# mod 연산은 덧셈, 뺄셈, 나눗셈에 대해서 분배법칙이 성립된다.
(a * b) % c == (a%c * b%c) % c;
# 아리스토테네스의 체
소수 : 1과 자기 자신 이외에는 나누어지지 않는 수, 소수 판별은 2부터 자기 자신 -1 까지 다 나누어 봐서 나머지가 0이 아닌것으로 알 수 있지만, 
루트씌운 제곱근 값 까지만 나누어 봐도 된다.  Math.sqrt(N) / i != 0

##############
# 강의 사이트 모의고사 사이트
##############
# leet code https://leetcode.com/

3C2 조합 resList(3) : [AB, AC, BC]
3C2 중복조합 resList(6) : [AA, AB, AC, BB, BC, CC]
3P2 순열 resList(6) : [AB, AC, BA, BC, CA, CB]
3P2 중복순열 resList(9) : [AA, AB, AC, BA, BB, BC, CA, CB, CC]


3P2 조합 부분집합 resList(6) : [A, AB, AC, B, BC, C]
3P2 중복조합 resList(9) :         [A, AA, AB, AC, B, BB, BC, C, CC]
3P2 순열 부분집합 resList(9) : [A, AB, AC, B, BA, BC, C, CA, CB]
3P2 중복순열 부분집합 resList(12) : [A, AA, AB, AC, B, BA, BB, BC, C, CA, CB, CC]

2023-05-27 토요일
# LeetCode - rooms & keys : 간단한 탐색
# LeetCode - Connected Components : 엣지를 --> 노드별 연결 목록 으로 변경해서
# MergeSort


2023-06-03 토요일
Infrun Ch.1 문자열 
5. 특정 문자 뒤집기
	문자 뒤집기 할 때 left++ 인덱스 right-- 인덱스로 Swap 할 수 있음
7. 회문 문자열
	문자 대칭인지 확인 할 때는  mid 값 까지만 반대편과 검사 하면 된다.
8. 유효한 팰린드롬
	문자 뒤집을 때 StringBuilder.reverse() 하면 간단하게 뒤집을 수 있음.
9. 숫자만 추출
	문자를 숫자로 바꿀 때 num = (num * 10) + (ch - '0') 으로 앞에서부터 읽어 나가면서 숫자를 만들 수 있음
10. 가장 짧은 문자거리
	내가 푼 방법 : 이중 루프로 문자마다 다시 문자열 길이만큼 루프돌면서 앞뒤칸 옮겨 가며 찾았으나
	더 좋은 방법 : 배열하나 놓고, 왼쪽으로 같은 문자면 0, 다른문자면 거리++ 하면서 한번 쭉 돌고, 다시 오른쪽으로 한번더해서 더 작은값
11. 문자열압축하기
	내가 푼 방법 : 인덱스 이전값과 비교해서 사후에 넣었으나
	더 좋은 방법 : 문자열 맨 뒤에 임시공백문자 하나 붙인 후, 인덱스를 문자열 길이 -1 까지 돌리면서, 인덱스 다음것 비교한다.
12. 문자열이진수값
	Integer.parseInt(str, 2) 하면 2진수로 파싱
